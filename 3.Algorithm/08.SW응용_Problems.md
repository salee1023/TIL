# SW응용 (Problems)

#### 문제 01) 5185. [파이썬 S/W 문제해결 구현] 1일차 - 이진수

#### 풀이 01) 

✔ 입력받은 16진수를 10진수로 변환한다. `int(x, 16)`

✔ 10진수를 4자리의 2진수로 변환한다. `format(x, '04b')`

```python
T = int(input())
for tc in range(1, 1+T):
    N, numbers = input().split()
    N = int(N)
    print(f'#{tc} ', end='')
    for n in range(N):
        t = format(int(numbers[n], 16), '04b')
        print(t, end='')
    print()
```

---

#### 문제 02) 5186. [파이썬 S/W 문제해결 구현] 1일차 - 이진수2

#### 풀이 02) 

✔ 실수에 2를 곱하여 정수부분을 차례로 출력한다.

![image-20201027112705045](08.Bit.assets/image-20201027112705045.png)

```python
T = int(input())
for tc in range(1, 1+T):
    N = float(input())
    res = ''
    l = 0
    while N:
        N *= 2
        l += 1
        temp = str(N)
        res += temp[0]
        if temp[0] == '1':
            N -= 1
        if l == 13:
            res = 'overflow'
            break
    print(f'#{tc} {res}')
```

---

#### 문제 03) [4366. 정식이의 은행업무](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWMeRLz6kC0DFAXd)

#### 풀이 03)

✔

✔

```python
def correct(i, n, mistake): # n진수 한자리씩 수정하는 함수
    temp = mistake[:]
    temp[i//n] = str(i % n)
    ans = ''.join(temp)
    return ans


def compare():
    for b in range(len(binary)*2):
        new_binary = correct(b, 2, binary)
        for t in range(len(ternary)*3):
            new_ternary = correct(t, 3, ternary)
            if int(new_binary, 2) == int(new_ternary, 3):
                print(f'#{tc} {int(new_binary, 2)}')
                return

#--------------------------------------------------
T = int(input())
for tc in range(1, 1+T):
    binary = list(input())
    ternary = list(input())
    compare()
```

---

#### 문제 04) 1240. [S/W 문제해결 응용] 1일차 - 단순 2진 암호코드

#### 풀이 04)

✔

✔

```python
def find_code(N, M):
    for i in range(N):
        for j in range(M-1, -1, -1):
            if arr[i][j] == '1':
                return arr[i][j-55:j+1]


def solve_code(code):
    answer = ''
    for i in range(8):
        mini_code = code[i*7:i*7+7]
        mini_code_solve = ''
        cnt = 1
        for j in range(6):
            if mini_code[j] == mini_code[j+1]:
                cnt += 1
            else:
                mini_code_solve += str(cnt)
                cnt = 1
        else:
            mini_code_solve += str(cnt)
            for p in range(10):
                if password[p] == mini_code_solve:
                    answer += str(p)
    return answer


def verify(answer):
    ans = 0
    for i in range(7):
        if (i+1) % 2:
            ans += int(answer[i])*3
        else:
            ans += int(answer[i])
    ans += int(answer[7])
    if ans % 10:
        return 0
    else:
        ans = 0
        for i in range(8):
            ans += int(answer[i])
        return ans

#---------------------------------------------------------------------------------------
password = ['3211', '2221', '2122', '1411', '1132', '1231', '1114', '1312', '1213', '3112']
T = int(input())
for tc in range(1, 1+T):
    N, M = map(int, input().split())
    arr = [input() for _ in range(N)]
    # 암호코드 추출하기
    code = find_code(N, M)
    # 암호 풀기
    answer = solve_code(code)
    # 암호 검증하기
    ans = verify(answer)
    print(f'#{tc} {ans}')
```

---

#### 문제 05) [1242. [S/W 문제해결 응용] 1일차 - 암호코드 스캔](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15JEKKAM8CFAYD)

#### 풀이 05)

```python

```

---

#### 문제 06) 5201. [파이썬 S/W 문제해결 구현] 3일차 - 컨테이너 운반

#### 풀이 06)

✔ 컨테이너의 무게와 화물차의 용량을 내림차순으로 정렬한다.

✔ 무게 < 용량일 때 : 남은 차 중 가장 큰 화물차에  컨테이너 1개를 넣는다.

✔ 무게 > 용량일 때 : 남은 차 중 가장 큰 화물차에  운반가능한 컨테이너 중 가장 무거운 컨테이너 1개를 넣는다.

```python
T = int(input())
for tc in range(1, 1+T):
    N, M = map(int, input().split())
    weight = list(map(int, input().split()))
    volume = list(map(int, input().split()))
    weight.sort(reverse=True)
    volume.sort(reverse=True)
    w = v = res = 0
    while w < N and v < M:
        if volume[v] >= weight[w]:
            res += weight[w]
            v += 1
            w += 1
        else:
            w += 1
    print(f'#{tc} {res}')
```

---

#### 문제 07) 5202. [파이썬 S/W 문제해결 구현] 3일차 - 화물 도크

#### 풀이 07)

✔ 종료시간 기준으로 정렬하고, 첫번째 작업은 무조건 선택한다.

✔ 현재 선택된 작업의 종료시간 이후에 시작하는 작업을 선택한다.

```python
T = int(input())
for tc in range(1, 1+T):
    N = int(input())
    time_table = [list(map(int, input().split())) for _ in range(N)]
    time_table.sort(key=lambda x: x[1])
    i = res = tmp = 0
    while i < N:
        if time_table[i][0] >= tmp:
            res += 1
            tmp = time_table[i][1]
        i += 1
    print(f'#{tc} {res}')
```

---

#### 문제 08) 5203. [파이썬 S/W 문제해결 구현] 3일차 - 베이비진 게임

#### 풀이 08)

✔ 카드를 한 장 씩 나누어 가질 때 마다 babygin 여부를 확인한다.

```python
def babygin():
    i = r1 = t1 = r2 = t2 = 0
    while i < 10:
        if (player1[i] >= 3) or (player1[i] >= 1 and player1[i+1] >= 1 and player1[i+2] >= 1):
            return 1
        if (player2[i] >= 3) or player2[i] >= 1 and player2[i+1] >= 1 and player2[i+2] >= 1:
            return 2    
        i += 1
    return 0

#------------------------------------------------
T = int(input())
for tc in range(1, 1+T):
    player1 = [0]*12
    player2 = [0]*12
    arr = list(map(int, input().split()))
    i = v = 0
    #  player1, player2에게 카드를 한 장 씩 나누어주며 babygin 여부를 확인한다.
    while i < 12:
        if i % 2:
            player2[arr[i]] += 1
        else:
            player1[arr[i]] += 1

        if i >= 4:
            res = babygin()
            # player1, player2중에 누군가 이겼을 때
            if res:
                print(f'#{tc} {res}')
                v = 1
        if v == 1:
            break
        i += 1
    # 끝까지 무승부이면 0 출력
    if v == 0:
        print(f'#{tc} 0')
```

---

#### 문제 09) 5188. [파이썬 S/W 문제해결 구현] 2일차 - 최소합

#### 풀이 09)

✔

✔

```python

```

---

#### 문제 10) 5189. [파이썬 S/W 문제해결 구현] 2일차 - 전자카트

#### 풀이 10)

```python

```

---

#### 문제 11)

#### 풀이 11)

```python

```

